# coding: utf-8

"""
    BRP bewoning

    API voor het raadplegen van de (historische) bewoning van een adres. 

    The version of the OpenAPI document: 2.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from brp_bewoning_client.models.bewoner import Bewoner
from brp_bewoning_client.models.periode import Periode
from typing import Optional, Set
from typing_extensions import Self

class Bewoning(BaseModel):
    """
    Een bewoning geeft aan welke personen in een periode (mogelijk) op een adresseerbaar object staan ingeschreven.  Een persoon is een mogelijke bewoner als niet met zekerheid kan worden bepaald of de persoon in de bewoningperiode op het adresseerbaar object staat/stond ingeschreven. Dit is het geval als de datum aanvang of de datum einde van de inschrijving geheel of deels onbekend is, en de onzekerheidsperiode overlapt de bewoningperiode.  Wanneer een bewoning in totaal meer dan 100 bewoners en/of mogelijke bewoners heeft, wordt het **indicatieVeelBewoners** veld geleverd. 
    """ # noqa: E501
    adresseerbaar_object_identificatie: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="De identificatiecode van een adresseerbaar object. ", alias="adresseerbaarObjectIdentificatie")
    periode: Optional[Periode] = None
    bewoners: Optional[Annotated[List[Bewoner], Field(min_length=0, max_length=100)]] = Field(default=None, description="De personen die in de bewoning periode staan ingeschreven op het adresseerbaar object. ")
    mogelijke_bewoners: Optional[Annotated[List[Bewoner], Field(min_length=0, max_length=100)]] = Field(default=None, description="De personen die in de bewoning periode mogelijk staan ingeschreven op het adresseerbaar object. ", alias="mogelijkeBewoners")
    indicatie_veel_bewoners: Optional[StrictBool] = Field(default=None, description="Geeft aan dat de bewoning in totaal meer dan 100 bewoners en/of mogelijke bewoners heeft. ", alias="indicatieVeelBewoners")
    __properties: ClassVar[List[str]] = ["adresseerbaarObjectIdentificatie", "periode", "bewoners", "mogelijkeBewoners", "indicatieVeelBewoners"]

    @field_validator('adresseerbaar_object_identificatie')
    def adresseerbaar_object_identificatie_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[0-9]{16}$", value):
            raise ValueError(r"must validate the regular expression /^[0-9]{16}$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Bewoning from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of periode
        if self.periode:
            _dict['periode'] = self.periode.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in bewoners (list)
        _items = []
        if self.bewoners:
            for _item_bewoners in self.bewoners:
                if _item_bewoners:
                    _items.append(_item_bewoners.to_dict())
            _dict['bewoners'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mogelijke_bewoners (list)
        _items = []
        if self.mogelijke_bewoners:
            for _item_mogelijke_bewoners in self.mogelijke_bewoners:
                if _item_mogelijke_bewoners:
                    _items.append(_item_mogelijke_bewoners.to_dict())
            _dict['mogelijkeBewoners'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Bewoning from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "adresseerbaarObjectIdentificatie": obj.get("adresseerbaarObjectIdentificatie"),
            "periode": Periode.from_dict(obj["periode"]) if obj.get("periode") is not None else None,
            "bewoners": [Bewoner.from_dict(_item) for _item in obj["bewoners"]] if obj.get("bewoners") is not None else None,
            "mogelijkeBewoners": [Bewoner.from_dict(_item) for _item in obj["mogelijkeBewoners"]] if obj.get("mogelijkeBewoners") is not None else None,
            "indicatieVeelBewoners": obj.get("indicatieVeelBewoners")
        })
        return _obj


